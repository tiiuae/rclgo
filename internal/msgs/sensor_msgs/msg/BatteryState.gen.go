/*
This file is part of rclgo

Copyright Â© 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package sensor_msgs_msg
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/rclgo/types"
	"github.com/tiiuae/rclgo/pkg/rclgo/typemap"
	std_msgs_msg "github.com/tiiuae/rclgo/internal/msgs/std_msgs/msg"
	primitives "github.com/tiiuae/rclgo/pkg/rclgo/primitives"
	
)
/*
#cgo LDFLAGS: -L/opt/ros/galactic/lib -Wl,-rpath=/opt/ros/galactic/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -lsensor_msgs__rosidl_typesupport_c -lsensor_msgs__rosidl_generator_c
#cgo LDFLAGS: -lstd_msgs__rosidl_typesupport_c -lstd_msgs__rosidl_generator_c

#cgo CFLAGS: -I/opt/ros/galactic/include

#include <rosidl_runtime_c/message_type_support_struct.h>

#include <sensor_msgs/msg/battery_state.h>

*/
import "C"

func init() {
	typemap.RegisterMessage("sensor_msgs/BatteryState", BatteryStateTypeSupport)
}
const (
	BatteryState_POWER_SUPPLY_STATUS_UNKNOWN uint8 = 0// Power supply status constants
	BatteryState_POWER_SUPPLY_STATUS_CHARGING uint8 = 1// Power supply status constants
	BatteryState_POWER_SUPPLY_STATUS_DISCHARGING uint8 = 2// Power supply status constants
	BatteryState_POWER_SUPPLY_STATUS_NOT_CHARGING uint8 = 3// Power supply status constants
	BatteryState_POWER_SUPPLY_STATUS_FULL uint8 = 4// Power supply status constants
	BatteryState_POWER_SUPPLY_HEALTH_UNKNOWN uint8 = 0// Power supply health constants
	BatteryState_POWER_SUPPLY_HEALTH_GOOD uint8 = 1// Power supply health constants
	BatteryState_POWER_SUPPLY_HEALTH_OVERHEAT uint8 = 2// Power supply health constants
	BatteryState_POWER_SUPPLY_HEALTH_DEAD uint8 = 3// Power supply health constants
	BatteryState_POWER_SUPPLY_HEALTH_OVERVOLTAGE uint8 = 4// Power supply health constants
	BatteryState_POWER_SUPPLY_HEALTH_UNSPEC_FAILURE uint8 = 5// Power supply health constants
	BatteryState_POWER_SUPPLY_HEALTH_COLD uint8 = 6// Power supply health constants
	BatteryState_POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE uint8 = 7// Power supply health constants
	BatteryState_POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE uint8 = 8// Power supply health constants
	BatteryState_POWER_SUPPLY_TECHNOLOGY_UNKNOWN uint8 = 0// Power supply technology (chemistry) constants
	BatteryState_POWER_SUPPLY_TECHNOLOGY_NIMH uint8 = 1// Power supply technology (chemistry) constants
	BatteryState_POWER_SUPPLY_TECHNOLOGY_LION uint8 = 2// Power supply technology (chemistry) constants
	BatteryState_POWER_SUPPLY_TECHNOLOGY_LIPO uint8 = 3// Power supply technology (chemistry) constants
	BatteryState_POWER_SUPPLY_TECHNOLOGY_LIFE uint8 = 4// Power supply technology (chemistry) constants
	BatteryState_POWER_SUPPLY_TECHNOLOGY_NICD uint8 = 5// Power supply technology (chemistry) constants
	BatteryState_POWER_SUPPLY_TECHNOLOGY_LIMN uint8 = 6// Power supply technology (chemistry) constants
)

// Do not create instances of this type directly. Always use NewBatteryState
// function instead.
type BatteryState struct {
	Header std_msgs_msg.Header `yaml:"header"`
	Voltage float32 `yaml:"voltage"`// Voltage in Volts (Mandatory)
	Temperature float32 `yaml:"temperature"`// Temperature in Degrees Celsius (If unmeasured NaN)
	Current float32 `yaml:"current"`// Negative when discharging (A)  (If unmeasured NaN)
	Charge float32 `yaml:"charge"`// Current charge in Ah  (If unmeasured NaN)
	Capacity float32 `yaml:"capacity"`// Capacity in Ah (last full capacity)  (If unmeasured NaN)
	DesignCapacity float32 `yaml:"design_capacity"`// Capacity in Ah (design capacity)  (If unmeasured NaN)
	Percentage float32 `yaml:"percentage"`// Charge percentage on 0 to 1 range  (If unmeasured NaN)
	PowerSupplyStatus uint8 `yaml:"power_supply_status"`// The charging status as reported. Values defined above
	PowerSupplyHealth uint8 `yaml:"power_supply_health"`// The battery health metric. Values defined above
	PowerSupplyTechnology uint8 `yaml:"power_supply_technology"`// The battery chemistry. Values defined above
	Present bool `yaml:"present"`// True if the battery is present
	CellVoltage []float32 `yaml:"cell_voltage"`// An array of individual cell voltages for each cell in the pack
	CellTemperature []float32 `yaml:"cell_temperature"`// An array of individual cell temperatures for each cell in the pack. If individual voltages unknown but number of cells known set each to NaN
	Location string `yaml:"location"`// The location into which the battery is inserted. (slot number or plug). If individual voltages unknown but number of cells known set each to NaNIf individual temperatures unknown but number of cells known set each to NaN
	SerialNumber string `yaml:"serial_number"`// The best approximation of the battery serial number. If individual voltages unknown but number of cells known set each to NaNIf individual temperatures unknown but number of cells known set each to NaN
}

// NewBatteryState creates a new BatteryState with default values.
func NewBatteryState() *BatteryState {
	self := BatteryState{}
	self.SetDefaults()
	return &self
}

func (t *BatteryState) Clone() *BatteryState {
	c := &BatteryState{}
	c.Header = *t.Header.Clone()
	c.Voltage = t.Voltage
	c.Temperature = t.Temperature
	c.Current = t.Current
	c.Charge = t.Charge
	c.Capacity = t.Capacity
	c.DesignCapacity = t.DesignCapacity
	c.Percentage = t.Percentage
	c.PowerSupplyStatus = t.PowerSupplyStatus
	c.PowerSupplyHealth = t.PowerSupplyHealth
	c.PowerSupplyTechnology = t.PowerSupplyTechnology
	c.Present = t.Present
	if t.CellVoltage != nil {
		c.CellVoltage = make([]float32, len(t.CellVoltage))
		copy(c.CellVoltage, t.CellVoltage)
	}
	if t.CellTemperature != nil {
		c.CellTemperature = make([]float32, len(t.CellTemperature))
		copy(c.CellTemperature, t.CellTemperature)
	}
	c.Location = t.Location
	c.SerialNumber = t.SerialNumber
	return c
}

func (t *BatteryState) CloneMsg() types.Message {
	return t.Clone()
}

func (t *BatteryState) SetDefaults() {
	t.Header.SetDefaults()
	t.Voltage = 0
	t.Temperature = 0
	t.Current = 0
	t.Charge = 0
	t.Capacity = 0
	t.DesignCapacity = 0
	t.Percentage = 0
	t.PowerSupplyStatus = 0
	t.PowerSupplyHealth = 0
	t.PowerSupplyTechnology = 0
	t.Present = false
	t.CellVoltage = nil
	t.CellTemperature = nil
	t.Location = ""
	t.SerialNumber = ""
}

// CloneBatteryStateSlice clones src to dst by calling Clone for each element in
// src. Panics if len(dst) < len(src).
func CloneBatteryStateSlice(dst, src []BatteryState) {
	for i := range src {
		dst[i] = *src[i].Clone()
	}
}

// Modifying this variable is undefined behavior.
var BatteryStateTypeSupport types.MessageTypeSupport = _BatteryStateTypeSupport{}

type _BatteryStateTypeSupport struct{}

func (t _BatteryStateTypeSupport) New() types.Message {
	return NewBatteryState()
}

func (t _BatteryStateTypeSupport) PrepareMemory() unsafe.Pointer { //returns *C.sensor_msgs__msg__BatteryState
	return (unsafe.Pointer)(C.sensor_msgs__msg__BatteryState__create())
}

func (t _BatteryStateTypeSupport) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.sensor_msgs__msg__BatteryState__destroy((*C.sensor_msgs__msg__BatteryState)(pointer_to_free))
}

func (t _BatteryStateTypeSupport) AsCStruct(dst unsafe.Pointer, msg types.Message) {
	m := msg.(*BatteryState)
	mem := (*C.sensor_msgs__msg__BatteryState)(dst)
	std_msgs_msg.HeaderTypeSupport.AsCStruct(unsafe.Pointer(&mem.header), &m.Header)
	mem.voltage = C.float(m.Voltage)
	mem.temperature = C.float(m.Temperature)
	mem.current = C.float(m.Current)
	mem.charge = C.float(m.Charge)
	mem.capacity = C.float(m.Capacity)
	mem.design_capacity = C.float(m.DesignCapacity)
	mem.percentage = C.float(m.Percentage)
	mem.power_supply_status = C.uint8_t(m.PowerSupplyStatus)
	mem.power_supply_health = C.uint8_t(m.PowerSupplyHealth)
	mem.power_supply_technology = C.uint8_t(m.PowerSupplyTechnology)
	mem.present = C.bool(m.Present)
	primitives.Float32__Sequence_to_C((*primitives.CFloat32__Sequence)(unsafe.Pointer(&mem.cell_voltage)), m.CellVoltage)
	primitives.Float32__Sequence_to_C((*primitives.CFloat32__Sequence)(unsafe.Pointer(&mem.cell_temperature)), m.CellTemperature)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.location), m.Location)
	primitives.StringAsCStruct(unsafe.Pointer(&mem.serial_number), m.SerialNumber)
}

func (t _BatteryStateTypeSupport) AsGoStruct(msg types.Message, ros2_message_buffer unsafe.Pointer) {
	m := msg.(*BatteryState)
	mem := (*C.sensor_msgs__msg__BatteryState)(ros2_message_buffer)
	std_msgs_msg.HeaderTypeSupport.AsGoStruct(&m.Header, unsafe.Pointer(&mem.header))
	m.Voltage = float32(mem.voltage)
	m.Temperature = float32(mem.temperature)
	m.Current = float32(mem.current)
	m.Charge = float32(mem.charge)
	m.Capacity = float32(mem.capacity)
	m.DesignCapacity = float32(mem.design_capacity)
	m.Percentage = float32(mem.percentage)
	m.PowerSupplyStatus = uint8(mem.power_supply_status)
	m.PowerSupplyHealth = uint8(mem.power_supply_health)
	m.PowerSupplyTechnology = uint8(mem.power_supply_technology)
	m.Present = bool(mem.present)
	primitives.Float32__Sequence_to_Go(&m.CellVoltage, *(*primitives.CFloat32__Sequence)(unsafe.Pointer(&mem.cell_voltage)))
	primitives.Float32__Sequence_to_Go(&m.CellTemperature, *(*primitives.CFloat32__Sequence)(unsafe.Pointer(&mem.cell_temperature)))
	primitives.StringAsGoStruct(&m.Location, unsafe.Pointer(&mem.location))
	primitives.StringAsGoStruct(&m.SerialNumber, unsafe.Pointer(&mem.serial_number))
}

func (t _BatteryStateTypeSupport) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__BatteryState())
}

type CBatteryState = C.sensor_msgs__msg__BatteryState
type CBatteryState__Sequence = C.sensor_msgs__msg__BatteryState__Sequence

func BatteryState__Sequence_to_Go(goSlice *[]BatteryState, cSlice CBatteryState__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]BatteryState, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.sensor_msgs__msg__BatteryState__Sequence)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_sensor_msgs__msg__BatteryState * uintptr(i)),
		))
		BatteryStateTypeSupport.AsGoStruct(&(*goSlice)[i], unsafe.Pointer(cIdx))
	}
}
func BatteryState__Sequence_to_C(cSlice *CBatteryState__Sequence, goSlice []BatteryState) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.sensor_msgs__msg__BatteryState)(C.malloc((C.size_t)(C.sizeof_struct_sensor_msgs__msg__BatteryState * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.sensor_msgs__msg__BatteryState)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_sensor_msgs__msg__BatteryState * uintptr(i)),
		))
		BatteryStateTypeSupport.AsCStruct(unsafe.Pointer(cIdx), &v)
	}
}
func BatteryState__Array_to_Go(goSlice []BatteryState, cSlice []CBatteryState) {
	for i := 0; i < len(cSlice); i++ {
		BatteryStateTypeSupport.AsGoStruct(&goSlice[i], unsafe.Pointer(&cSlice[i]))
	}
}
func BatteryState__Array_to_C(cSlice []CBatteryState, goSlice []BatteryState) {
	for i := 0; i < len(goSlice); i++ {
		BatteryStateTypeSupport.AsCStruct(unsafe.Pointer(&cSlice[i]), &goSlice[i])
	}
}

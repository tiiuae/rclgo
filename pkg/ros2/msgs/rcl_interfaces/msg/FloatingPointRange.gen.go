/*
This file is part of rclgo

Copyright Â© 2021 Technology Innovation Institute, United Arab Emirates

Licensed under the Apache License, Version 2.0 (the "License");
	http://www.apache.org/licenses/LICENSE-2.0
*/

/*
THIS FILE IS AUTOGENERATED BY 'rclgo-gen generate'
*/

package rcl_interfaces
import (
	"unsafe"

	"github.com/tiiuae/rclgo/pkg/ros2/ros2types"
	"github.com/tiiuae/rclgo/pkg/ros2/ros2_type_dispatcher"
	
)
/*
#cgo LDFLAGS: -L/opt/ros/foxy/lib -Wl,-rpath=/opt/ros/foxy/lib -lrcl -lrosidl_runtime_c -lrosidl_typesupport_c -lrcutils -lrmw_implementation
#cgo LDFLAGS: -lrcl_interfaces__rosidl_typesupport_c -lrcl_interfaces__rosidl_generator_c

#cgo CFLAGS: -I/opt/ros/foxy/include

#include <rosidl_runtime_c/message_type_support_struct.h>
#include <rcl_interfaces/msg/floating_point_range.h>
*/
import "C"

func init() {
	ros2_type_dispatcher.RegisterROS2MsgTypeNameAlias("rcl_interfaces/FloatingPointRange", &FloatingPointRange{})
}

// Do not create instances of this type directly. Always use NewFloatingPointRange
// function instead.
type FloatingPointRange struct {
	FromValue float64 `yaml:"from_value"`// Start value for valid values, inclusive.
	ToValue float64 `yaml:"to_value"`// End value for valid values, inclusive.
	Step float64 `yaml:"step"`// Size of valid steps between the from and to bound.Step is considered to be a magnitude, therefore negative values are treatedthe same as positive values, and a step value of zero implies a continuousrange of values.Ideally, the step would be less than or equal to the distance between thebounds, as well as an even multiple of the distance between the bounds, butneither are required.If the absolute value of the step is larger than or equal to the distancebetween the two bounds, then the bounds will be the only valid values. e.g. ifthe range is defined as {from_value: 1.0, to_value: 2.0, step: 5.0} then thevalid values will be 1.0 and 2.0.If the step is less than the distance between the bounds, but the distance isnot a multiple of the step, then the "to" bound will always be a valid value,e.g. if the range is defined as {from_value: 2.0, to_value: 5.0, step: 2.0}then the valid values will be 2.0, 4.0, and 5.0.
}

// NewFloatingPointRange creates a new FloatingPointRange with default values.
func NewFloatingPointRange() *FloatingPointRange {
	self := FloatingPointRange{}
	self.SetDefaults(nil)
	return &self
}

func (t *FloatingPointRange) SetDefaults(d interface{}) ros2types.ROS2Msg {
	
	return t
}

func (t *FloatingPointRange) TypeSupport() unsafe.Pointer {
	return unsafe.Pointer(C.rosidl_typesupport_c__get_message_type_support_handle__rcl_interfaces__msg__FloatingPointRange())
}
func (t *FloatingPointRange) PrepareMemory() unsafe.Pointer { //returns *C.rcl_interfaces__msg__FloatingPointRange
	return (unsafe.Pointer)(C.rcl_interfaces__msg__FloatingPointRange__create())
}
func (t *FloatingPointRange) ReleaseMemory(pointer_to_free unsafe.Pointer) {
	C.rcl_interfaces__msg__FloatingPointRange__destroy((*C.rcl_interfaces__msg__FloatingPointRange)(pointer_to_free))
}
func (t *FloatingPointRange) AsCStruct() unsafe.Pointer {
	mem := (*C.rcl_interfaces__msg__FloatingPointRange)(t.PrepareMemory())
	mem.from_value = C.double(t.FromValue)
	mem.to_value = C.double(t.ToValue)
	mem.step = C.double(t.Step)
	return unsafe.Pointer(mem)
}
func (t *FloatingPointRange) AsGoStruct(ros2_message_buffer unsafe.Pointer) {
	mem := (*C.rcl_interfaces__msg__FloatingPointRange)(ros2_message_buffer)
	t.FromValue = float64(mem.from_value)
	t.ToValue = float64(mem.to_value)
	t.Step = float64(mem.step)
}
func (t *FloatingPointRange) Clone() ros2types.ROS2Msg {
	clone := *t
	return &clone
}

type CFloatingPointRange = C.rcl_interfaces__msg__FloatingPointRange
type CFloatingPointRange__Sequence = C.rcl_interfaces__msg__FloatingPointRange__Sequence

func FloatingPointRange__Sequence_to_Go(goSlice *[]FloatingPointRange, cSlice CFloatingPointRange__Sequence) {
	if cSlice.size == 0 {
		return
	}
	*goSlice = make([]FloatingPointRange, int64(cSlice.size))
	for i := 0; i < int(cSlice.size); i++ {
		cIdx := (*C.rcl_interfaces__msg__FloatingPointRange__Sequence)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_rcl_interfaces__msg__FloatingPointRange * uintptr(i)),
		))
		(*goSlice)[i] = FloatingPointRange{}
		(*goSlice)[i].AsGoStruct(unsafe.Pointer(cIdx))
	}
}
func FloatingPointRange__Sequence_to_C(cSlice *CFloatingPointRange__Sequence, goSlice []FloatingPointRange) {
	if len(goSlice) == 0 {
		return
	}
	cSlice.data = (*C.rcl_interfaces__msg__FloatingPointRange)(C.malloc((C.size_t)(C.sizeof_struct_rcl_interfaces__msg__FloatingPointRange * uintptr(len(goSlice)))))
	cSlice.capacity = C.size_t(len(goSlice))
	cSlice.size = cSlice.capacity

	for i, v := range goSlice {
		cIdx := (*C.rcl_interfaces__msg__FloatingPointRange)(unsafe.Pointer(
			uintptr(unsafe.Pointer(cSlice.data)) + (C.sizeof_struct_rcl_interfaces__msg__FloatingPointRange * uintptr(i)),
		))
		*cIdx = *(*C.rcl_interfaces__msg__FloatingPointRange)(v.AsCStruct())
	}
}
func FloatingPointRange__Array_to_Go(goSlice []FloatingPointRange, cSlice []CFloatingPointRange) {
	for i := 0; i < len(cSlice); i++ {
		goSlice[i].AsGoStruct(unsafe.Pointer(&cSlice[i]))
	}
}
func FloatingPointRange__Array_to_C(cSlice []CFloatingPointRange, goSlice []FloatingPointRange) {
	for i := 0; i < len(goSlice); i++ {
		cSlice[i] = *(*C.rcl_interfaces__msg__FloatingPointRange)(goSlice[i].AsCStruct())
	}
}


